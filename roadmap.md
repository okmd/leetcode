# Roadmap to complete the Product based Interview for SDE-1

## Nearly ~ 500 problem needed to be sloved

## General 100 days plan

1. Programming revison for [1-3] days.
2. Ds&Algo: concepts+easy problem [4-60] days.
3. Problem solving: Different pattern question [60-90] days.
4. Advanced Data structure [90-95].
5. Misc Topics [95-100].

```
Note:
    1.  LLD/HLD are required for SDE 2 not SDE-1 but take an idea.
    2.  Choose only one language to program python/C++ with STL.
    3.  For finance choose C++.[DE Shaw]
```

`Day:01-03` Revison:

- Basics of programming.
- Object oriented programming.
- Pointers.
- [Python](https://edabit.com/challenges) atleast 50 question.

`Day:04-04` Algorithmic time complexity.

`Day:05-25` Basic Data structure 4 days per topics:

1. [Arrays](href="https://leetcode.com/tag/array/")
2. [Linkedlist](href="https://leetcode.com/tag/linked-list/")
3. [Stack](href="https://leetcode.com/tag/stack/")
4. [Queues](href="https://leetcode.com/tag/queue/")
5. [Strings](href="https://leetcode.com/tag/string/")

NOTE: For all the problems analysie Time and space complexity, when to use and practice easy problem.

`Day:26-40` Algorithm:

1. [Searching[2 days]](href="https://leetcode.com/tag/binary-search/")
2. [Sorting[1]](href="https://leetcode.com/tag/sort/")
3. [Divide and Conqure[2 days]](href="https://leetcode.com/tag/divide-conqure/")
4. [Greedy Algorithm[3 days]](href="https://leetcode.com/tag/greedy/")
5. [Dyanamic Programming[7 days]](href="https://leetcode.com/tag/dynamic-programming/")

NOTE: Practice easy 15-20 problems on each topics.

`Day:41-60` Non-Linear Data structure:

1. [Binary tree - BT, BST, AVL[8 days]](href="https://leetcode.com/tag/tree/")
2. [Heaps[2 days]](href="https://leetcode.com/tag/heap/")
3. [Hashing[2 days]](href="https://leetcode.com/tag/hash-table/")
4. [Graph, BFS, DFS[5 days]](href="https://leetcode.com/tag/breadth-first-search/")
5. [Backtracking[3 days]](href="https://leetcode.com/tag/backtracking/")

`Day:61-90` Problem solving and Pattern problems:

- Fast and Slow points
  1. [Linked list cycle..](href="https://leetcode.com/tag/#/)
  2. [Middle of linked list.](href="https://leetcode.com/tag/#/)
  3. [Happy number.](href="https://leetcode.com/tag/#/)
- DFS
  1. [min depth of binary tree.](href="https://leetcode.com/tag/#/)
  2. [number of islands.](href="https://leetcode.com/tag/#/)
  3. [critical connection in a n/w.](href="https://leetcode.com/tag/#/)
  4. [clone graph.](href="https://leetcode.com/tag/#/)
  5. [path sum.](href="https://leetcode.com/tag/#/)
- Bitwiese Xor
  1. [Single num.](href="https://leetcode.com/tag/#/)
  2. [two single num.](href="https://leetcode.com/tag/#/)
  3. [counting bits.](href="https://leetcode.com/tag/#/)
- Two heaps
  1. [Fin median of num stream.](href="https://leetcode.com/tag/#/)
  2. [Sliding window median.](href="https://leetcode.com/tag/#/)
  3. [Maximize capital.](href="https://leetcode.com/tag/#/)
- Modified binary search
  1. [Median of two sorted array.](href="https://leetcode.com/tag/#/)
  2. [Ceiling of a number.](href="https://leetcode.com/tag/#/)
  3. [Search in a sorted infinte array.](href="https://leetcode.com/tag/#/)
  4. [Bitonic array maximum.](href="https://leetcode.com/tag/#/)
- Top k-elements
  1. [Kth-smallest element.](href="https://leetcode.com/tag/#/)
  2. [Connect ropes..](href="https://leetcode.com/tag/#/)
  3. [Kth largest element in stream.](href="https://leetcode.com/tag/#/)
  4. [k-closest numbers.](href="https://leetcode.com/tag/#/)
- k-way merge
  1. [Merge k sorted lists.](href="https://leetcode.com/tag/#/)
  2. [Kth smallest num in m sorted lists.](href="https://leetcode.com/tag/#/)
  3. [Kth largest element in stream.](href="https://leetcode.com/tag/#/)
  4. [Kth smllest number in a sorted matrix.](href="https://leetcode.com/tag/#/)
  5. [Smallest number range.](href="https://leetcode.com/tag/#/)
- 0/1 knapsack DP
  1. [equal subset sum partition.](href="https://leetcode.com/tag/#/)
  2. [min subset sum diff.](href="https://leetcode.com/tag/#/)
  3. [0/1 knapsack.](href="https://leetcode.com/tag/#/)
- topological sort
  1. [tasks scheduling.](href="https://leetcode.com/tag/#/)
  2. [task scheduling order.](href="https://leetcode.com/tag/#/)
  3. [alien dictionary.](href="https://leetcode.com/tag/#/)
- subsets
  1. [balanced paranthesis.](href="https://leetcode.com/tag/#/)
  2. [subset with duplicates.](href="https://leetcode.com/tag/#/)
  3. [permutations.](href="https://leetcode.com/tag/#/)
- Merge interval
  1. [Merge intervals problem.](href="https://leetcode.com/tag/#/)
  2. [Insert interval..](href="https://leetcode.com/tag/#/)
  3. [Interval intersection.](href="https://leetcode.com/tag/#/)
  4. [Conflictong appointments.](href="https://leetcode.com/tag/#/)
- Sliding windows
  1. [longest substring without repeating chars.](href="https://leetcode.com/tag/#/)
  2. [sliding window max.](href="https://leetcode.com/tag/#/)
  3. [min, windows substring](href="https://leetcode.com/tag/#/)
  4. [num of submatrices that sum to target.](href="https://leetcode.com/tag/#/)
- Minimum and Maximum
  1. [Guess number higher or lower.](href="https://leetcode.com/tag/#/)
  2. [Stone Game.](href="https://leetcode.com/tag/#/)
  3. [Guess the word](href="https://leetcode.com/tag/#/)

`Day:91-95` Advanced Data structure:

1. Tries
2. Disjoint sets
3. BT and B+T
4. Red black tree RBT
5. Segment Trees

`Day:96-100` Computational complexity theory:

1. Np-complete and Np-hard computational complexity theory
2. knapsack problem
3. travelling salesman problem

```
NOTE:
    Target speed for easy to medium problem should be ideally 20-25 min.
    For harder problem it may 30 to 35 min.
    Read - 3-5min
    pseudocode - 5-7min
    time and space -2min
    code 10-15min
    handle all boundary cases while coding.
```

## Youtybe content

[Tech Dose Playlsit Leet Code](https://www.youtube.com/c/TECHDOSE4u/playlists)

## Refrence 

- [Topic Refrence AppliedInterviewPrep](https://www.youtube.com/watch?v=twN2kDfeSQY&t=2790s&ab_channel=AppliedAICourse)